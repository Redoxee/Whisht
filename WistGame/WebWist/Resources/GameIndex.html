<!doctype html>
<meta charset="utf-8">
<style>
    #output {
        overflow: auto;
        float: right;
        border: 1pt;
        border-color: black;
        border-style: solid;
        min-width: 300pt;
        max-width: 50%;
    }

    #output > p {
        overflow-wrap: break-word;
    }

    #output span {
        color: blue;
    }

    #output span.error {
        color: red;
    }

    .bet {
        text-align : center;
    }

        .bet p {
            margin: 0pt;
        }

    .card {
        border : 1pt;
        border-style : solid;
        border-color : darkgray;
    }

    .otherPlayer {
        border: 1pt;
        border-style: solid;
        border-color: black;
    }


</style>
<h2>Whist</h2>
<div id=playArea></div>
<div id=output></div>
<script>
    const GameStateID = [
        "Initialize",
        "Betting",
        "Fold",
        "EndGame",
        "Unkown"];

    const SigilLabel = [
        "Spade",
        "Club",
        "Heart",
        "Diamond"];

    const SigilSymbol = [
        '\u2660',
        '\u2663',
        '\u2661',
        '\u2662'];

    const ValueLabel = [
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "Jack",
        "Queen",
        "King",
        "Ace",
    ];

    var websocket = null;
    var isConnected = false;
    var gameWebSocketUrl = document.URL.replace("http://", "ws://");

    var output = document.querySelector("#output");

    var playArea = document.querySelector("#playArea");
    var currentPlayerObject = {};
    var playerObject = {};

    var otherPlayersParent = document.createElement("table");
    var otherPlayers = [];

    var currentState = "None";
    var localPlayerIndex = -1;
    var availableSlots = [];
    var nextOrderID = 0;

    var pendingOrders = [];
    var messageHandles = [];
    var gameState = null;

    messageHandles["AvailablePlayerSlots"] = handleAvailablePlayerSlots;
    messageHandles["OrderAcknowledgement"] = handleOrderAcknowledgement;
    messageHandles["PlayerViewUpdate"] = handlePlayerViewUpdate;
    messageHandles["SandboxChanges"] = handleSandboxUpdate;

    writeToScreen("WS URI " + gameWebSocketUrl);

    createWebSocket();


    function doSend(message) {
        writeToScreen("SENT: " + message);
        websocket.send(message);
    }

    function writeToScreen(message) {
        output.insertAdjacentHTML("afterbegin", "<p>" + message + "</p>");
    }

    function recieveWebSocketMessage(e) {
        var messageData = null;
        writeToScreen("Recieving message " + e.data);
        try {
            messageData = JSON.parse(e.data);
        }
        catch (error) {
            writeToScreen("error while parsing json" + error.message);
        }

        if (messageData.MessageType in messageHandles) {
            messageHandles[messageData.MessageType](messageData);
        }
        else {
            writeToScreen("Unkown message type.");
        }
    }

    function createWebSocket() {
        console.log(gameWebSocketUrl);
        websocket = new WebSocket(gameWebSocketUrl);

        websocket.onopen = function (e) {
            isConnected = true;
            writeToScreen("CONNECTED");
            var requestPlayerSlots = '{ "OrderType": "RequestPlayerSlots" }';
            doSend(requestPlayerSlots);
        };

        websocket.onclose = function (e) {
            writeToScreen("DISCONNECTED");
        };

        websocket.onmessage = recieveWebSocketMessage;

        websocket.onerror = function (e) {
            writeToScreen("<span class=error>ERROR:</span> " + e.data);
        };
    }

    function handleOrderAcknowledgement(messageData) {
        if (pendingOrders[messageData.OrderID] != null) {
            pendingOrders[messageData.OrderID](messageData);
            pendingOrders[messageData.OrderID] = null;
        }else {
            writeToScreen("No acknowledgment found for order " + messageData.OrderID + ".");

            var pendingOrderKeys = pendingOrders.keys();
            var keyMessage = "PendingOrder keys :";
            for (const key of pendingOrderKeys) {
                keyMessage += " " + key;
            }

            writeToScreen(keyMessage);
        }
    }

    function handleAvailablePlayerSlots(messageData)
    {
        availableSlots = messageData.AvaialablePlayerSlots;

        if (localPlayerIndex < 0) {
            clearPlayArea();
            var numberOfSlots = 0;
            if (availableSlots.length > 0) {
                var table = document.createElement("table");
                var tr = document.createElement("tr");
                table.appendChild(tr);
                for (var index = 0; index < availableSlots.length; ++index) {
                    if (availableSlots[index]) {
                        numberOfSlots++;
                        var th = document.createElement("th");
                        var playerSlotButton = document.createElement("button");
                        th.appendChild(playerSlotButton);
                        tr.appendChild(th);

                        playerSlotButton.appendChild(document.createTextNode("Player " + (index + 1)));
                        (function (i) {
                            playerSlotButton.addEventListener("click", function () {
                                requestPlayerSlots(i);
                            })
                        })(index);
                    }
                }

                if (numberOfSlots >= 0) {
                    playArea.appendChild(table);
                }
            }

            if (numberOfSlots <= 0) {
                var p = document.createElement("p").appendChild(document.createTextNode("No more slots available"));
                playArea.appendChild(p);
            }
        }

        else {
            var numberOfAvailableSlots = 0;
            for (var index = 0; index < availableSlots.length; ++index) {
                if (availableSlots[index]) {
                    numberOfAvailableSlots++;
                }
            }

            if (numberOfAvailableSlots > 0) {
                clearPlayArea();

                var p = document.createElement("p").appendChild(document.createTextNode("Waiting for " + numberOfAvailableSlots + " players."));
                playArea.appendChild(p);
            }
            else {
                if (currentState == "None") {
                    if (gameState == null) {
                        currentState = "WaitingForGameState";
                    }
                    else {
                        SetupFromGameState();
                    }
                }
            }
        }
    }

    function handlePlayerViewUpdate(messageData)
    {
        gameState = messageData;

        if (GameStateID[gameState.GameStateID] != null) {
            gameState.GameStateID = GameStateID[gameState.GameStateID];
        }

        if (currentState == "WaitingForGameState") {
            SetupFromGameState();
        }
    }

    function handleSandboxUpdate(messageData) {
        for (var changeIndex = 0; messageData.GameChanges.length; ++changeIndex) {
            var gameChange = messageData.GameChanges[changeIndex];
            if (gameChange.ChangeType == "GameStateChange") {
                gameState.GameStateID = gameChange.GameChanges;

                currentPlayerObject.Label.textContent = currentPlayerObject.Message + gameChange.PlayerIndex;
            }
            else if (gameChange.ChangeType == "PlayerBet") {
                if (gameChange.PlayerIndex == localPlayerIndex) {
                }
                else {
                    var otherPlayerObject = otherPlayers[gameChange.PlayerIndex];
                    otherPlayerObject.BetLabel.textContent = "Bet " + gameChange.BetValue;
                }
            }
            else if (gameChange.ChangeType == "PlayedCard") {
            }
            else if (gameChange.ChangeType == "NextPlayer") {
                currentPlayerObject.Label.textContent = currentPlayerObject.Message + gameChange.PlayerIndex;
            }
        }
    }

    function SetupFromGameState() {
        clearPlayArea();

        if (gameState.GameStateID == "Betting" || gameState.GameStateID == "Fold") {
            var currentPlayer = buildCurrentPlayer();
            playArea.appendChild(currentPlayer.RootNode);

            buildOtherPlayersNode();
            playArea.appendChild(otherPlayersParent);

            buildPlayer();
            playArea.appendChild(playerObject.RootNode);

            if (gameState.GameStateID == "Betting") {
                playArea.appendChild(playerObject.PlayerBets.RootNode);
            }
        }
    }

    function buildCurrentPlayer()
    {
        currentPlayerObject.RootNode = document.createElement("p");
        currentPlayerObject.Message = "Current player : ";
        currentPlayerObject.Label = document.createTextNode(currentPlayerObject.Message + gameState.CurrentPlayer);
        currentPlayerObject.RootNode.appendChild(currentPlayerObject.Label);

        return currentPlayerObject;
    }

    function buildPlayer() {
        playerObject.RootNode = createElementWithClass("table", "player");
        playerObject.PlayerLabel = document.createTextNode("Player " + localPlayerIndex);
        var paragraph = document.createElement("p");
        paragraph.appendChild(playerObject.PlayerLabel);
        playerObject.RootNode.appendChild(paragraph);

        playerObject.Hand = buildPlayerHand();
        playerObject.RootNode.appendChild(playerObject.Hand.RootNode);

        playerObject.BetLabel = document.createTextNode("Betting " + gameState.Bet);
        if (gameState.Bet >= 0) {
            playerObject.RootNode.appendChild(playerObject.BetLabel);
        } 

        playerObject.PlayerBets = buildPlayerBetting();

        return playerObject;
    }

    function buildPlayerHand() {
        var playerHand = {};
        playerHand.RootNode = createElementWithClass("table", "playerHand");
        playerHand.Cards = [];

        for (var index = 0; index < gameState.Hand.length; ++index) {
            var cardData = gameState.Hand[index];
            var column = document.createElement("th");
            var cardObject = buildCard(cardData);
            column.appendChild(cardObject.RootNode);
            playerHand.RootNode.appendChild(column);
            playerHand.Cards[index] = cardObject;
        }

        return playerHand;
    }

    function buildCard(cardData) {
        var cardObject = {};
        cardObject.RootNode = createElementWithClass("div", "card");
        cardObject.CardLabel = document.createTextNode(ValueLabel[cardData.Value] + " of " + SigilSymbol[cardData.Sigil]);
        cardObject.RootNode.appendChild(cardObject.CardLabel);

        return cardObject;
    }

    function buildPlayerBetting() {
        var playerBetting = {};

        playerBetting.RootNode = document.createElement("table");
        playerBetting.BettingNode = document.createElement("tr");
        playerBetting.RootNode.appendChild(playerBetting.BettingNode);

        var numberOfBets = gameState.BetFailures.length;
        for (var index = 0; index < numberOfBets; ++index) {
            var betObject = buildBetObject();
            betObject.MainLabel.textContent = index;

            playerBetting.BettingNode.appendChild(betObject.BetRootNode);

            if (gameState.BetFailures[index] != 0) {
                betObject.Button.disabled = true;
            }
            else {
                (function (bet) {
                    betObject.Button.addEventListener("click", function () {
                        requestBet(bet);
                    });
                })(index);
            }
        }

        return playerBetting;
    }

    function buildBetObject() {
        var bet = {};
        bet.BetRootNode = createElementWithClass("th", "bet");
        var table = document.createElement("table");
        bet.BetRootNode.appendChild(table);

        var paragraphe = document.createElement("p");
        table.appendChild(paragraphe);
        bet.MainLabel = document.createTextNode("");
        paragraphe.appendChild(bet.MainLabel);

        bet.Button = document.createElement("button");
        bet.Button.appendChild(document.createTextNode("bet"));
        table.appendChild(bet.Button);

        return bet;
    }

    function buildOtherPlayersNode() {
        clearChilds(otherPlayersParent);

        var numberOfPlayers = gameState.OtherPlayers.length;
        for (var index = 0; index < numberOfPlayers; ++index) {
            if (index == localPlayerIndex) {
                continue;
            }

            var otherPlayerObject = {};
            var otherPlayerData = gameState.OtherPlayers[index];

            otherPlayerObject.PlayerLabel = document.createTextNode("Player " + (index + 1));
            otherPlayerObject.ScoreLabel = document.createTextNode("Current score " + otherPlayerData.CurrentScore);
            otherPlayerObject.BetLabel = document.createTextNode("Current bet " + otherPlayerData.Bet);
            otherPlayerObject.NumberOfCardsLabel = document.createTextNode("Number of cards " + otherPlayerData.NumberOfCards);

            otherPlayerObject.RootNode = createElementWithClass("table", "otherPlayer");
            var row = document.createElement("tr");
            row.appendChild(otherPlayerObject.PlayerLabel);
            otherPlayerObject.RootNode.appendChild(row);
            row = document.createElement("tr");
            row.appendChild(otherPlayerObject.ScoreLabel);
            otherPlayerObject.RootNode.appendChild(row);
            row = document.createElement("tr");
            row.appendChild(otherPlayerObject.BetLabel);
            otherPlayerObject.RootNode.appendChild(row);
            row = document.createElement("tr");
            row.appendChild(otherPlayerObject.NumberOfCardsLabel);
            otherPlayerObject.RootNode.appendChild(row);
            otherPlayers[index] = otherPlayerObject;
            otherPlayersParent.appendChild(otherPlayerObject.RootNode);
        }
    }

    function requestPlayerSlots(requestedIndex) {
        if (localPlayerIndex >= 0) {
            return;
        }

        if (!availableSlots[requestedIndex]) {
            return;
        }

        var orderID = nextOrderID++;
        var requestPlayerIndex = '{"OrderType":"SelectPlayerSlot", "PlayerIndex": ' + requestedIndex + ', "OrderID" : ' + orderID + '}';
        pendingOrders[orderID] = function (responseData) {
            if (responseData.FailureFlags == 0) {
                localPlayerIndex = requestedIndex;
            }
        };

        doSend(requestPlayerIndex);
    }

    function requestBet(betValue) {
        var orderID = nextOrderID++;
        var betOrder = '{"OrderType":"PlaceBet", "BetValue": ' + betValue + ', "OrderID" : ' + orderID + '}';
        pendingOrders[orderID] = function (responseData) {
            if (responseData.FailureFlags == 0) {
            }
        };

        doSend(betOrder);
    }

    function clearChilds(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    function clearPlayArea() {
        while (playArea.firstChild) {
            playArea.removeChild(playArea.firstChild)
        }
    }

    function createElementWithClass(element, className) {
        var el = document.createElement(element);
        el.className = className;
        return el;
    }

</script>